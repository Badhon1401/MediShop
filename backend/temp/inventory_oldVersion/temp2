// com/mediShop/inventory/domain/entity/Inventory.java
package com.mediShop.inventory.domain.entity;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import com.mediShop.medicine.domain.valueobject.MedicineType;

public class Inventory {
    private final Integer inventoryId;
    private Integer medicineId;
    private String batchNumber;
    private String companyName;
    private LocalDate expiryDate;
    private String location;
    private LocalDateTime lastUpdated;
    private MedicineType type;
    private Integer supplierId;
    private LocalDate buyingDate;
    private Integer totalQuantity;
    private Integer availableQuantity;
    private BigDecimal unitPrice;
    private BigDecimal buyingPrice;
    private BigDecimal discount;

    public Inventory(Integer inventoryId, Integer medicineId, String batchNumber,
                     String companyName, LocalDate expiryDate, String location,
                     MedicineType type, Integer supplierId, LocalDate buyingDate,
                     Integer totalQuantity, Integer availableQuantity,
                     BigDecimal unitPrice, BigDecimal buyingPrice, BigDecimal discount) {
        this.inventoryId = inventoryId;
        this.medicineId = validateMedicineId(medicineId);
        this.batchNumber = validateBatchNumber(batchNumber);
        this.companyName = validateCompanyName(companyName);
        this.expiryDate = validateExpiryDate(expiryDate);
        this.location = validateLocation(location);
        this.type = type;
        this.supplierId = supplierId;
        this.buyingDate = validateBuyingDate(buyingDate);
        this.totalQuantity = validateTotalQuantity(totalQuantity);
        this.availableQuantity = validateAvailableQuantity(availableQuantity, totalQuantity);
        this.unitPrice = validateUnitPrice(unitPrice);
        this.buyingPrice = validateBuyingPrice(buyingPrice);
        this.discount = validateDiscount(discount);
        this.lastUpdated = LocalDateTime.now();
    }

    public static Inventory create(Integer medicineId, String batchNumber,
                                   String companyName, LocalDate expiryDate,
                                   String location, MedicineType type,
                                   Integer supplierId, LocalDate buyingDate,
                                   Integer totalQuantity, BigDecimal unitPrice,
                                   BigDecimal buyingPrice, BigDecimal discount) {
        return new Inventory(null, medicineId, batchNumber, companyName,
                expiryDate, location, type, supplierId, buyingDate,
                totalQuantity, totalQuantity, unitPrice, buyingPrice, discount);
    }

    private Integer validateMedicineId(Integer medicineId) {
        if (medicineId == null || medicineId <= 0) {
            throw new IllegalArgumentException("Medicine ID must be positive");
        }
        return medicineId;
    }

    private String validateBatchNumber(String batchNumber) {
        if (batchNumber == null || batchNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Batch number cannot be empty");
        }
        return batchNumber.trim();
    }

    private String validateCompanyName(String companyName) {
        if (companyName == null || companyName.trim().isEmpty()) {
            throw new IllegalArgumentException("Company name cannot be empty");
        }
        return companyName.trim();
    }

    private LocalDate validateExpiryDate(LocalDate expiryDate) {
        if (expiryDate == null) {
            throw new IllegalArgumentException("Expiry date cannot be null");
        }
        if (expiryDate.isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("Expiry date cannot be in the past");
        }
        return expiryDate;
    }

    private String validateLocation(String location) {
        if (location == null || location.trim().isEmpty()) {
            throw new IllegalArgumentException("Location cannot be empty");
        }
        return location.trim();
    }

    private LocalDate validateBuyingDate(LocalDate buyingDate) {
        if (buyingDate == null) {
            throw new IllegalArgumentException("Buying date cannot be null");
        }
        if (buyingDate.isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Buying date cannot be in the future");
        }
        return buyingDate;
    }

    private Integer validateTotalQuantity(Integer totalQuantity) {
        if (totalQuantity == null || totalQuantity < 0) {
            throw new IllegalArgumentException("Total quantity must be non-negative");
        }
        return totalQuantity;
    }

    private Integer validateAvailableQuantity(Integer availableQuantity, Integer totalQuantity) {
        if (availableQuantity == null || availableQuantity < 0) {
            throw new IllegalArgumentException("Available quantity must be non-negative");
        }
        if (totalQuantity != null && availableQuantity > totalQuantity) {
            throw new IllegalArgumentException("Available quantity cannot exceed total quantity");
        }
        return availableQuantity;
    }

    private BigDecimal validateUnitPrice(BigDecimal unitPrice) {
        if (unitPrice == null || unitPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Unit price must be non-negative");
        }
        return unitPrice;
    }

    private BigDecimal validateBuyingPrice(BigDecimal buyingPrice) {
        if (buyingPrice == null || buyingPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Buying price must be non-negative");
        }
        return buyingPrice;
    }

    private BigDecimal validateDiscount(BigDecimal discount) {
        if (discount == null) {
            return BigDecimal.ZERO;
        }
        if (discount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Discount must be non-negative");
        }
        return discount;
    }

    public boolean isExpired() {
        return LocalDate.now().isAfter(expiryDate);
    }

    public boolean isNearExpiry(int daysThreshold) {
        return LocalDate.now().plusDays(daysThreshold).isAfter(expiryDate) ||
                LocalDate.now().plusDays(daysThreshold).isEqual(expiryDate);
    }

    public boolean isLowStock(int threshold) {
        return availableQuantity <= threshold;
    }

    public boolean isOutOfStock() {
        return availableQuantity == 0;
    }

    public void updateStock(Integer newAvailableQuantity) {
        this.availableQuantity = validateAvailableQuantity(newAvailableQuantity, totalQuantity);
        this.lastUpdated = LocalDateTime.now();
    }

    public void updatePricing(BigDecimal unitPrice, BigDecimal discount) {
        this.unitPrice = validateUnitPrice(unitPrice);
        this.discount = validateDiscount(discount);
        this.lastUpdated = LocalDateTime.now();
    }

    public void updateLocation(String location) {
        this.location = validateLocation(location);
        this.lastUpdated = LocalDateTime.now();
    }

    public BigDecimal getEffectivePrice() {
        return unitPrice.subtract(discount);
    }

    public BigDecimal getTotalValue() {
        return getEffectivePrice().multiply(BigDecimal.valueOf(availableQuantity));
    }

    public Integer getUsedQuantity() {
        return totalQuantity - availableQuantity;
    }

    // Getters
    public Integer getInventoryId() { return inventoryId; }
    public Integer getMedicineId() { return medicineId; }
    public String getBatchNumber() { return batchNumber; }
    public String getCompanyName() { return companyName; }
    public LocalDate getExpiryDate() { return expiryDate; }
    public String getLocation() { return location; }
    public LocalDateTime getLastUpdated() { return lastUpdated; }
    public MedicineType getType() { return type; }
    public Integer getSupplierId() { return supplierId; }
    public LocalDate getBuyingDate() { return buyingDate; }
    public Integer getTotalQuantity() { return totalQuantity; }
    public Integer getAvailableQuantity() { return availableQuantity; }
    public BigDecimal getUnitPrice() { return unitPrice; }
    public BigDecimal getBuyingPrice() { return buyingPrice; }
    public BigDecimal getDiscount() { return discount; }

    public void updateDetails(String companyName2, LocalDate expiryDate2, String location2, BigDecimal unitPrice2,
            BigDecimal discount2) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'updateDetails'");
    }

    public void addStock(Integer quantity) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'addStock'");
    }

    public void removeStock(Integer quantity) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'removeStock'");
    }

    public void setAvailableQuantity(Integer quantity) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'setAvailableQuantity'");
    }

    public String getMedicineName() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getMedicineName'");
    }
}


package com.mediShop.inventory.domain.repository;

import com.mediShop.inventory.domain.entity.Inventory;
import com.mediShop.medicine.domain.valueobject.MedicineType;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

public interface InventoryRepository {
    Inventory save(Inventory inventory);
    Optional<Inventory> findById(Integer inventoryId);
    List<Inventory> findAll();
    List<Inventory> findByMedicineId(Integer medicineId);
    List<Inventory> findByBatchNumber(String batchNumber);
    List<Inventory> findByCompanyName(String companyName);
    List<Inventory> findByLocation(String location);
    List<Inventory> findByType(MedicineType type);
    List<Inventory> findBySupplierId(Integer supplierId);
    List<Inventory> findExpiringBefore(LocalDate date);
    List<Inventory> findExpiredInventory();
    List<Inventory> findLowStockItems(Integer threshold);
    List<Inventory> findOutOfStockItems();
    List<Inventory> findByBuyingDateBetween(LocalDate startDate, LocalDate endDate);
    List<Inventory> findByUnitPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);
    List<Inventory> findByAvailableQuantityGreaterThan(Integer quantity);
    boolean existsByMedicineIdAndBatchNumber(Integer medicineId, String batchNumber);
    void deleteById(Integer inventoryId);
    BigDecimal getTotalInventoryValue();
    Integer getTotalAvailableQuantity();
    List<Inventory> findLowStockInventory();
    List<Inventory> searchInventory(String medicineName, String batchNumber, String companyName, MedicineType type,
            Integer supplierId, String location, Boolean expired, Boolean lowStock, LocalDate expiryDateFrom,
            LocalDate expiryDateTo, Integer page, Integer size, String sortBy, String sortDirection);
    
    
}


// AddInventoryRequest.java
package com.mediShop.inventory.application.dto;

import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDate;

public class AddInventoryRequest {
    @NotNull(message = "Medicine ID is required")
    @Positive(message = "Medicine ID must be positive")
    private Integer medicineId;

    @NotBlank(message = "Batch number is required")
    @Size(max = 50, message = "Batch number must not exceed 50 characters")
    private String batchNumber;

    @NotBlank(message = "Company name is required")
    @Size(max = 100, message = "Company name must not exceed 100 characters")
    private String companyName;

    @NotNull(message = "Expiry date is required")
    @Future(message = "Expiry date must be in the future")
    private LocalDate expiryDate;

    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;

    @NotNull(message = "Supplier ID is required")
    @Positive(message = "Supplier ID must be positive")
    private Integer supplierId;

    @NotNull(message = "Buying date is required")
    @PastOrPresent(message = "Buying date cannot be in the future")
    private LocalDate buyingDate;

    @NotNull(message = "Total quantity is required")
    @Positive(message = "Total quantity must be positive")
    private Integer totalQuantity;

    @NotNull(message = "Unit price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Unit price must be greater than 0")
    @Digits(integer = 10, fraction = 2, message = "Unit price must have maximum 2 decimal places")
    private BigDecimal unitPrice;

    @NotNull(message = "Buying price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Buying price must be greater than 0")
    @Digits(integer = 10, fraction = 2, message = "Buying price must have maximum 2 decimal places")
    private BigDecimal buyingPrice;

    @DecimalMin(value = "0.0", message = "Discount cannot be negative")
    @DecimalMax(value = "100.0", message = "Discount cannot exceed 100%")
    @Digits(integer = 3, fraction = 2, message = "Discount must have maximum 2 decimal places")
    private BigDecimal discount = BigDecimal.ZERO;

    public AddInventoryRequest() {}

    public AddInventoryRequest(Integer medicineId, String batchNumber, String companyName,
                               LocalDate expiryDate, String location, Integer supplierId,
                               LocalDate buyingDate, Integer totalQuantity, BigDecimal unitPrice,
                               BigDecimal buyingPrice, BigDecimal discount) {
        this.medicineId = medicineId;
        this.batchNumber = batchNumber;
        this.companyName = companyName;
        this.expiryDate = expiryDate;
        this.location = location;
        this.supplierId = supplierId;
        this.buyingDate = buyingDate;
        this.totalQuantity = totalQuantity;
        this.unitPrice = unitPrice;
        this.buyingPrice = buyingPrice;
        this.discount = discount;
    }

    // Getters and Setters
    public Integer getMedicineId() { return medicineId; }
    public void setMedicineId(Integer medicineId) { this.medicineId = medicineId; }

    public String getBatchNumber() { return batchNumber; }
    public void setBatchNumber(String batchNumber) { this.batchNumber = batchNumber; }

    public String getCompanyName() { return companyName; }
    public void setCompanyName(String companyName) { this.companyName = companyName; }

    public LocalDate getExpiryDate() { return expiryDate; }
    public void setExpiryDate(LocalDate expiryDate) { this.expiryDate = expiryDate; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public Integer getSupplierId() { return supplierId; }
    public void setSupplierId(Integer supplierId) { this.supplierId = supplierId; }

    public LocalDate getBuyingDate() { return buyingDate; }
    public void setBuyingDate(LocalDate buyingDate) { this.buyingDate = buyingDate; }

    public Integer getTotalQuantity() { return totalQuantity; }
    public void setTotalQuantity(Integer totalQuantity) { this.totalQuantity = totalQuantity; }

    public BigDecimal getUnitPrice() { return unitPrice; }
    public void setUnitPrice(BigDecimal unitPrice) { this.unitPrice = unitPrice; }

    public BigDecimal getBuyingPrice() { return buyingPrice; }
    public void setBuyingPrice(BigDecimal buyingPrice) { this.buyingPrice = buyingPrice; }

    public BigDecimal getDiscount() { return discount; }
    public void setDiscount(BigDecimal discount) { this.discount = discount; }
}
